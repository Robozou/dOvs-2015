structure A = Absyn
structure S = Symbol

(* [these functions and similar ones may be convenient
 * for the creation of abstract syntax trees] *)

datatype lvaluePartSpec = Field of S.symbol
                        | Subscript of A.exp

fun makeLvaluePartSpec (v, pos, l::r) =
  (case l
    of Field idsym =>
       makeLvaluePartSpec (A.FieldVar (v, idsym, pos), pos, r)
     | Subscript exp =>
       makeLvaluePartSpec (A.SubscriptVar (v, exp, pos), pos,r))
  | makeLvaluePartSpec (v, _, nil) = v

fun makeBinop (e1, bop, e2, p) =
    A.OpExp  { left = e1
             , oper = bop
             , right = e2
             , pos = p}

fun makeIf (et, en, el, p) =
    A.IfExp  { test = et
             , thn = en
             , els = el
             , pos = p}

fun makeVarDec (idsym, ty, e, p) =
    A.VarDec { name = idsym
             , escape = ref true
             , typ = ty
             , init = e
             , pos = p}

fun makeFundecl (idsym, ps, rty, e, p) =
             { name = idsym
             , params = ps
             , result = rty
             , body = e
             , pos = p} : A.fundecldata

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | UMINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | CARET
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

(* [add missing nonterminals; in second phase: add semantic values] *)

%nonterm program
       | exp
       | exps
       | seqexp
       | recfields
       | decl
       | decls
       | tydecl
       | ty
       | tyfields
       | vardecl
       | fundecl
       | lvalue

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION
         VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* [specify precedence/associativity, least tight binding first] *)

%left       AND OR
%nonassoc   FUNCTION VAR TYPE THEN DO OF ASSIGN NEQ GT LT GE LE EQ
%left       PLUS MINUS
%left       TIMES DIVIDE
%right      CARET
%right      UMINUS
(* [..more tokens & levels..] *)

%%

(* Top level constructs *)

(* Program *)
program   : exp                                                ()

(* Expressions *)
exp       : INT                                                ()
   |        NIL                                                ()
   |        STRING                                             ()
   |        lvalue                                             ()
   |        lvalue ASSIGN exp                                  ()
   |        ID LBRACK exp RBRACK OF exp                        ()
   |        IF exp THEN exp ELSE exp                           ()
   |        IF exp THEN exp                                    ()
   |        WHILE exp DO exp                                   ()
   |        FOR ID ASSIGN exp TO exp DO exp                    ()
   |        BREAK                                              ()
   |        LET decls IN seqexp END                            ()
   |        LPAREN seqexp RPAREN                               ()
   |        ID LBRACE recfields RBRACE                         ()
   |        ID LPAREN exps RPAREN                              ()
   (* Binary operators *)
   |        exp EQ exp                                         ()
   |        exp OR exp                                         ()
   |        exp AND exp                                        ()
   |        exp LE exp                                         ()
   |        exp GE exp                                         ()
   |        exp LT exp                                         ()
   |        exp GT exp                                         ()
   |        exp NEQ exp                                        ()
   |        exp MINUS exp                                      ()
   |        exp PLUS exp                                       ()
   |        exp DIVIDE exp                                     ()
   |        exp TIMES exp                                      ()
   |        exp CARET exp                                      ()
   |        MINUS exp  %prec UMINUS                            ()
    (* [..missing rules for exp..] *)

exps      :                                                    ()
   |        exp                                                ()
   |        exps COMMA exp                                     ()

seqexp    :                                                    ()
   |        exp                                                ()
   |        seqexp SEMICOLON exp                               ()

(* Record fields *)
recfields :                                                    () (* We get an error test 49, since NIL is not included, but if we do this, 29 reduce/reduce errors follow *)
   |        ID EQ exp                                          ()
   |        ID EQ exp COMMA recfields                          ()

(* Declarations *)
decl      : tydecl                                             ()
   |        vardecl                                            ()
   |        fundecl                                            ()

decls     : decl                                               ()
   |        decl decls                                         ()

(* Type declarations *)
tydecl    : TYPE ID EQ ty                                      ()

ty        : ID                                                 ()
   |        LBRACE tyfields RBRACE                             ()
   |        ARRAY OF ID                                        ()

tyfields  :                                                    ()
   |        ID COLON ID                                        ()
   |        ID COLON ID COMMA tyfields                         ()

(* Variable declarations *)
vardecl   : VAR ID ASSIGN exp                                  ()
   |        VAR ID COLON ID ASSIGN exp                         ()

(* Function declarations *)
fundecl   : FUNCTION ID LPAREN tyfields RPAREN EQ exp          ()
   |        FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp ()

(* Left values *)
lvalue    : ID                                                 ()
   |        lvalue DOT ID                                      ()
   |        lvalue LBRACK exp RBRACK                           ()
   |        ID LBRACK exp RBRACK                               () (* lvalue did not see ID when handling arrays, so we had to introduce this rule for many tests *)
(* [..missing rules for missing nonterminals..] *)
