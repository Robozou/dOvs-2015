structure A = Absyn
structure S = Symbol

(* [these functions and similar ones may be convenient
 * for the creation of abstract syntax trees] *)

datatype lvaluePartSpec = Field of S.symbol
                        | Subscript of A.exp

fun makeLvaluePartSpec (v, pos, l::r) =
  (case l
    of Field idsym =>
       makeLvaluePartSpec (A.FieldVar (v, idsym, pos), pos, r)
     | Subscript exp =>
       makeLvaluePartSpec (A.SubscriptVar (v, exp, pos), pos,r))
  | makeLvaluePartSpec (v, _, nil) = v

fun makeBinop (e1, bop, e2, p) =
    A.OpExp  { left = e1
             , oper = bop
             , right = e2
             , pos = p}

fun makeIf (et, en, el, p) =
    A.IfExp  { test = et
             , thn = en
             , els = el
             , pos = p}

fun makeVarDec (idsym, ty, e, p) =
             { name = idsym
             , escape = ref true
             , typ = ty
             , init = e
             , pos = p} : A.vardecldata

fun makeFundecl (idsym, ps, rty, e, p) =
             { name = idsym
             , params = ps
             , result = rty
             , body = e
             , pos = p} : A.fundecldata

fun makeTyDec (idsym, t, p) =
	     { name = idsym
	     , ty = t
	     , pos = p} : A.tydecldata

fun makeForExp (idsym, el, eh, eb, p) =
    A.ForExp { var = idsym
	     , escape = ref true
	     , lo = el
	     , hi = eh
	     , body = eb
	     , pos = p}

fun makeWhileExp (et, eb, p) =
    A.WhileExp { test = et
	       , body = eb
	       , pos = p}

fun makeLetExp (decs, eb, p) =
    A.LetExp { decls = decs
	     , body = eb
	     , pos = p}

fun makeCallExp (fnc, ags, p) =
    A.CallExp { func = fnc
	      , args = ags
	      , pos = p}

fun makeArExp (ty, sz, ini, p) =
    A.ArrayExp { typ = ty
	       , size = sz
	       , init = ini
	       , pos = p}

fun makeAssign (idsym, e, p) =
    A.AssignExp { var = idsym
		, exp = e
		, pos = p}

fun makeRecExp (flds, ty, p) =
    A.RecordExp { fields = flds
		, typ = ty
		, pos = p}

fun makeFieldData (idsym, ty, p) =
                { name = idsym
		, escape = ref true
		, typ = ty
		, pos = p} : A.fielddata


%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | UMINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | CARET
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

(* [add missing nonterminals; in second phase: add semantic values] *)

%nonterm program of A.exp
       | exp of A.exp
       | exps of A.exp list
       | seqexp of (A.exp * pos) list
       | recfields of (S.symbol * A.exp * pos) list
       | decl of A.decl
       | decls of A.decl list
       | tydecl of A.tydecldata
       | ty of A.ty
       | tyfields of A.fielddata list
       | vardecl of A.vardecldata
       | fundecl of A.fundecldata
       | lvalue of A.var
       | lvalue_p of A.exp

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION
         VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* [specify precedence/associativity, least tight binding first] *)

%left       AND OR
%nonassoc   FUNCTION VAR TYPE THEN DO OF ASSIGN NEQ GT LT GE LE EQ
%right      ELSE
%left       PLUS MINUS
%left       TIMES DIVIDE
%right      CARET
%right      UMINUS


(* [..more tokens & levels..] *)

%%

(* Top level constructs *)

(* Program *)
program   : exp                                                (exp)

(* Expressions *)
exp       : INT                                                (A.IntExp INT)
   |        NIL                                                (A.NilExp)
   |        STRING                                             (A.StringExp (STRING, STRINGleft))
   |        lvalue                                             (A.VarExp(lvalue))
   |        lvalue ASSIGN exp                                  (makeAssign(lvalue,exp,lvalueleft)) (*Rule 5*)
   |        ID LBRACK exp RBRACK OF exp                        ()
   |        IF exp THEN exp ELSE exp                           (makeIf(exp1,exp2,SOME exp3,IFleft))
   |        IF exp THEN exp                                    (makeIf(exp1,exp2,NONE,IFleft))
   |        WHILE exp DO exp                                   (makeWhileExp(exp1,exp2,WHILEleft))
   |        FOR ID ASSIGN exp TO exp DO exp                    (makeForExp(S.symbol(ID),exp1,exp2,exp3,FORleft)) (*Rule 10*)
   |        BREAK                                              (A.BreakExp BREAKleft)
   |        LET decls IN seqexp END                            (makeLetExp(decls,A.SeqExp(seqexp),LETleft))
   |        LPAREN seqexp RPAREN                               (A.SeqExp(seqexp))
   |        ID LBRACE recfields RBRACE                         ()
   |        ID LPAREN exps RPAREN                              () (*Rule 15*)
   (* Binary operators *)
   |        exp OR exp                                         (makeIf(exp1,A.IntExp(1),SOME exp2,exp1left))
   |        exp AND exp                                        (makeIf(exp1,exp2,SOME (A.IntExp(0)),exp1left))
   |        exp EQ exp                                         (makeBinop(exp1,A.EqOp,exp2,exp1left))
   |        exp LE exp                                         (makeBinop(exp1,A.LeOp,exp2,exp1left))
   |        exp GE exp                                         (makeBinop(exp1,A.GeOp,exp2,exp1left)) (*Rule 20*)
   |        exp LT exp                                         (makeBinop(exp1,A.LtOp,exp2,exp1left))
   |        exp GT exp                                         (makeBinop(exp1,A.GtOp,exp2,exp1left))
   |        exp NEQ exp                                        (makeBinop(exp1,A.NeqOp,exp2,exp1left))
   |        exp MINUS exp                                      (makeBinop(exp1,A.MinusOp,exp2,exp1left))
   |        exp PLUS exp                                       (makeBinop(exp1,A.PlusOp,exp2,exp1left)) (*Rule 25*)
   |        exp DIVIDE exp                                     (makeBinop(exp1,A.DivideOp,exp2,exp1left))
   |        exp TIMES exp                                      (makeBinop(exp1,A.TimesOp,exp2,exp1left))
   |        exp CARET exp                                      (makeBinop(exp1,A.ExponentOp,exp2,exp1left))
   |        MINUS exp  %prec UMINUS                            (makeBinop(A.IntExp(0),A.MinusOp,exp,MINUSleft))
    (* [..missing rules for exp..] *)

exps      :                                                    ([]) (*Rule 30*)
   |        exp                                                ([exp])
   |        exps COMMA exp                                     (exps@[exp])

seqexp    :                                                    ([])
   |        exp                                                ([(exp,expleft)])
   |        seqexp SEMICOLON exp                               (seqexp@[(exp,expleft)]) (*Rule 35*)

(* Record fields *)
recfields :                                                    ([]) 
   |        ID EQ exp                                          ()
   |        ID EQ exp COMMA recfields                          ()

(* Declarations *)
decl      : tydecl                                             ()
   |        vardecl                                            () (*Rule 40*)
   |        fundecl                                            ()

decls     :                                                    (nil)
   |        decl decls                                         (decls @ [decl])

(* Type declarations *)
tydecl    : TYPE ID EQ ty                                      (makeTyDec(S.symbol(ID),ty,TYPEleft))

ty        : ID                                                 (A.NameTy(S.symbol(ID),IDleft)) (*Rule 45*)
   |        LBRACE tyfields RBRACE                             (A.RecordTy(tyfields))
   |        ARRAY OF ID                                        (A.ArrayTy(S.symbol(ID),IDleft))

tyfields  :                                                    (nil)
   |        ID COLON ID                                        ([makeFieldData(S.symbol(ID1), (S.symbol(ID2),ID2left),ID1left)])
   |        ID COLON ID COMMA tyfields                         (tyfields @ [makeFieldData(S.symbol(ID1), (S.symbol(ID2),ID2left),ID1left)]) (*Rule 50*)

(* Variable declarations *)
vardecl   : VAR ID ASSIGN exp                                  (makeVarDec(S.symbol(ID),NONE,exp,VARleft))
   |        VAR ID COLON ID ASSIGN exp                         (makeVarDec(S.symbol(ID1), SOME (S.symbol(ID2),ID2left), exp, VARleft))

(* Function declarations *)
fundecl   : FUNCTION ID LPAREN tyfields RPAREN EQ exp          ()
   |        FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp ()

(* Left values *)
lvalue    : ID                                                 (A.SimpleVar(S.symbol(ID),IDleft))
	  | lvalue_p                                           (lvalue_p)

lvalue_p  : ID DOT ID                                          ()
	  | lvalue_p DOT ID                                    ()
	  | lvalue_p LBRACK exp RBRACK                         ()
          | ID LBRACK exp RBRACK                               ()
